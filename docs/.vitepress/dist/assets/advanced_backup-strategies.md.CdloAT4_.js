import{_ as t,c as a,o as i,a2 as o}from"./chunks/framework.BUjRcKcJ.js";const p=JSON.parse('{"title":"Backup Strategies","description":"","frontmatter":{"title":"Backup Strategies","layout":"doc"},"headers":[],"relativePath":"advanced/backup-strategies.md","filePath":"advanced/backup-strategies.md","lastUpdated":1759030567000}'),r={name:"advanced/backup-strategies.md"};function s(d,e,l,c,n,u){return i(),a("div",null,e[0]||(e[0]=[o('<h1 id="backup-strategies" tabindex="-1">Backup Strategies <a class="header-anchor" href="#backup-strategies" aria-label="Permalink to &quot;Backup Strategies&quot;">​</a></h1><p>Migrated from <code>codex/collab/backup-strategies.md</code>, this guide documents battle-tested workflows for protecting configuration, metadata, and media states across the stack.</p><h2 id="backup-layers" tabindex="-1">Backup Layers <a class="header-anchor" href="#backup-layers" aria-label="Permalink to &quot;Backup Layers&quot;">​</a></h2><ol><li><strong>Configuration Snapshots</strong><ul><li>Triggered with <code>./usenet backup create</code>.</li><li>Stores compressed archives in <code>backups/</code> with timestamped names.</li><li>Includes API keys, automation scripts, and Docker Compose overlays.</li></ul></li><li><strong>Application Databases</strong><ul><li>Postgres-backed apps (e.g., Lidarr) dump to <code>/var/lib/postgresql</code>.</li><li>Lightweight sqlite stores are captured through bind mounts.</li></ul></li><li><strong>Media Storage</strong><ul><li>Rely on filesystem-level snapshots using ZFS or Btrfs.</li><li>Incremental replication handled by <code>zfs send</code> or <code>btrfs send</code> jobs.</li></ul></li></ol><h2 id="schedule-matrix" tabindex="-1">Schedule Matrix <a class="header-anchor" href="#schedule-matrix" aria-label="Permalink to &quot;Schedule Matrix&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Layer</th><th>Frequency</th><th>Retention</th><th>Tooling</th></tr></thead><tbody><tr><td>Config snapshots</td><td>Daily</td><td>14 days</td><td><code>./usenet backup</code></td></tr><tr><td>Databases</td><td>6 hours</td><td>7 days</td><td>Cron + <code>docker exec</code></td></tr><tr><td>Media snapshots</td><td>Hourly</td><td>48 hours</td><td>ZFS/Btrfs native tools</td></tr><tr><td>Off-site sync</td><td>Daily</td><td>30 days</td><td><code>rclone</code> + object store</td></tr></tbody></table><h2 id="off-site-replication" tabindex="-1">Off-Site Replication <a class="header-anchor" href="#off-site-replication" aria-label="Permalink to &quot;Off-Site Replication&quot;">​</a></h2><ol><li>Encrypt the archive using <code>age</code> before upload.</li><li>Push to an S3-compatible bucket using <code>rclone copy</code>. Set lifecycle policies on the bucket so older archives purge automatically.</li><li>Store the decrypt key on a hardware token stored off-site.</li></ol><h2 id="disaster-recovery-drill" tabindex="-1">Disaster Recovery Drill <a class="header-anchor" href="#disaster-recovery-drill" aria-label="Permalink to &quot;Disaster Recovery Drill&quot;">​</a></h2><ul><li>Restore the latest config snapshot to a staging host.</li><li>Run <code>./usenet deploy --validate-only</code> to catch credential drift.</li><li>Execute sample automation to confirm API integrations work.</li><li>Document the drill in your operational runbook with timestamps.</li></ul><h2 id="advanced-tips" tabindex="-1">Advanced Tips <a class="header-anchor" href="#advanced-tips" aria-label="Permalink to &quot;Advanced Tips&quot;">​</a></h2><ul><li>Enable Netdata cloud backups if you rely on its historical dashboards.</li><li>Script verification of archive integrity using <code>sha256sum</code> before deleting local copies.</li><li>Maintain a manifest file describing the contents of each archive to accelerate restores under pressure.</li></ul>',12)]))}const b=t(r,[["render",s]]);export{p as __pageData,b as default};
