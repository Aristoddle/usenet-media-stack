import{_ as o,c as t,o as a,a2 as r}from"./chunks/framework.BUjRcKcJ.js";const p=JSON.parse('{"title":"vNext Cluster Plan (PC + Laptops + 6‚Äì8 RPi5)","description":"","frontmatter":{},"headers":[],"relativePath":"vnext-cluster-plan.md","filePath":"vnext-cluster-plan.md","lastUpdated":1765661144000}'),s={name:"vnext-cluster-plan.md"};function i(n,e,l,d,c,m){return a(),t("div",null,e[0]||(e[0]=[r('<h1 id="vnext-cluster-plan-pc-laptops-6‚Äì8-rpi5" tabindex="-1">vNext Cluster Plan (PC + Laptops + 6‚Äì8 RPi5) <a class="header-anchor" href="#vnext-cluster-plan-pc-laptops-6‚Äì8-rpi5" aria-label="Permalink to &quot;vNext Cluster Plan (PC + Laptops + 6‚Äì8 RPi5)&quot;">‚Äã</a></h1><h2 id="assumptions-non-goals-invariants" tabindex="-1">Assumptions / Non-goals / Invariants <a class="header-anchor" href="#assumptions-non-goals-invariants" aria-label="Permalink to &quot;Assumptions / Non-goals / Invariants&quot;">‚Äã</a></h2><ul><li>Content lives outside the stack; the repo must rehydrate ‚Äútools, not data‚Äù on any host.</li><li>State must be explicit (bind mounts), backed up, and reversible before deletion.</li><li>Boot must converge without babysitting: services wait for mounts, restart safely.</li><li>Security posture may differ by runtime: rootless acceptable for single-host; rootful required for Swarm/k8s nodes.</li></ul><h2 id="tl-dr" tabindex="-1">TL;DR <a class="header-anchor" href="#tl-dr" aria-label="Permalink to &quot;TL;DR&quot;">‚Äã</a></h2><ul><li>Keep today‚Äôs compose setup (Komga/Komf + Arr stack) on Podman/Docker with bind-mounted configs.</li><li>Post-reboot, enable Docker daemon for Swarm/K8s experiments.</li><li>Long-term: prefer <strong>k3s</strong> (lightweight Kubernetes) with PC control-plane, RPis as workers, laptops tainted/ephemeral. <a href="https://docs.k3s.io/" target="_blank" rel="noreferrer">k3s docs</a></li></ul><h2 id="why-k3s-over-swarm-for-this-hardware-mix" tabindex="-1">Why k3s over Swarm (for this hardware mix) <a class="header-anchor" href="#why-k3s-over-swarm-for-this-hardware-mix" aria-label="Permalink to &quot;Why k3s over Swarm (for this hardware mix)&quot;">‚Äã</a></h2><ul><li>Multi-arch &amp; edge-focused: single binary, minimal deps, ARM builds. <a href="https://docs.k3s.io/" target="_blank" rel="noreferrer">k3s docs</a> ¬∑ <a href="https://github.com/k3s-io/k3s" target="_blank" rel="noreferrer">k3s GitHub</a></li><li>Small control-plane footprint: k3s is positioned for edge/IoT; typical RAM use is markedly lower than full k8s. (Vendor positioning; measure on your hosts.)</li><li>Ecosystem depth (ingress, cert-manager, GitOps) and active velocity vs. Swarm‚Äôs slower cadence.</li><li>Swarm still supported (Mirantis committed through 2030) but <strong>rootless Swarm is unsupported</strong> because overlay networking is unavailable in rootless Docker. <a href="https://www.mirantis.com/blog/mirantis-guarantees-long-term-support-for-swarm/" target="_blank" rel="noreferrer">Mirantis LTS</a> ¬∑ <a href="https://docs.docker.com/engine/security/rootless/#known-limitations" target="_blank" rel="noreferrer">Docker rootless limitations</a></li></ul><h2 id="near-term-steps-before-cluster-work" tabindex="-1">Near-term steps (before cluster work) <a class="header-anchor" href="#near-term-steps-before-cluster-work" aria-label="Permalink to &quot;Near-term steps (before cluster work)&quot;">‚Äã</a></h2><ol><li>Make Komga/Komf runtime-agnostic: bind-mount <code>/config</code> and <code>/tmp</code>; drive paths via <code>.env</code> and <code>docker-compose.komga.yml</code>.</li><li>Keep compose as single source of truth; run with <code>podman compose</code> today, <code>docker compose</code> after reboot.</li><li>Post-reboot: enable Docker service + docker group; optional: keep Podman for dev/testing.</li><li>Stop generating single-container systemd units; prefer Quadlet or a user service that runs <code>podman compose up -d</code>. <a href="https://docs.podman.io/en/latest/markdown/podman-generate-systemd.1.html" target="_blank" rel="noreferrer">Podman systemd deprecation</a></li><li>Compose implementation: standardize on <strong>podman compose</strong> (v4+) with the Docker Compose V2 provider installed (<code>docker compose</code> in PATH) and <strong>docker compose v2</strong> on Docker hosts. Avoid the legacy <code>podman-compose</code> shim and avoid compose features known to differ (e.g., experimental <code>secrets</code> drivers); stick to v3.9 services/volumes/env/binds which both runtimes support. <a href="https://www.redhat.com/en/blog/podman-compose-docker-compose" target="_blank" rel="noreferrer">Red Hat compose guidance</a> ¬∑ <a href="https://docs.podman.io/en/v5.6.2/markdown/podman-compose.1.html" target="_blank" rel="noreferrer">podman-compose provider note</a></li></ol><h2 id="medium-term-k3s-bootstrap" tabindex="-1">Medium-term (k3s bootstrap) <a class="header-anchor" href="#medium-term-k3s-bootstrap" aria-label="Permalink to &quot;Medium-term (k3s bootstrap)&quot;">‚Äã</a></h2><ol><li>Install k3s on the PC (single control-plane).</li><li>Join RPi5s as workers; label/taint <code>arm64</code> / <code>low-mem</code>; fence laptops as ‚Äúburst-only‚Äù.</li><li>Storage: NFS share from PC; install NFS CSI and StorageClass. (Avoid distributed storage across RPis unless HA is required.)</li><li>Ingress/TLS: ingress-nginx + cert-manager.</li><li>Deploy Komga/Komf via Helm/Kustomize; reuse <code>COMICS_ROOT</code>, <code>KOMGA_CONFIG</code>, <code>KOMGA_TMP</code>.</li><li>CI/build: <code>docker buildx bake</code> multi-arch (amd64/arm64) ‚Üí GHCR; pull by platform in k3s.</li></ol><h2 id="swarm-fallback-if-you-choose-it" tabindex="-1">Swarm fallback (if you choose it) <a class="header-anchor" href="#swarm-fallback-if-you-choose-it" aria-label="Permalink to &quot;Swarm fallback (if you choose it)&quot;">‚Äã</a></h2><ul><li>Keep compose v3.9 files; add <code>deploy</code> blocks and placement constraints.</li><li>Run Swarm only in rootful Docker (rootless Swarm unsupported). <a href="https://docs.docker.com/engine/security/rootless/#known-limitations" target="_blank" rel="noreferrer">Docker rootless limitations</a></li><li>If using bind mounts, paths must exist on every node where tasks may land; otherwise pin tasks with placement constraints or use shared storage. <a href="https://docs.docker.com/engine/swarm/services/#bind-mounts" target="_blank" rel="noreferrer">Swarm bind-mount requirement</a></li><li>Note: <code>docker stack deploy</code> uses the legacy Compose v3 subset; avoid Compose-spec-only features or maintain a swarm-specific override file. <a href="https://docs.docker.com/engine/swarm/stack-deploy/" target="_blank" rel="noreferrer">Docker stack deploy</a></li></ul><h2 id="risks-mitigations" tabindex="-1">Risks / Mitigations <a class="header-anchor" href="#risks-mitigations" aria-label="Permalink to &quot;Risks / Mitigations&quot;">‚Äã</a></h2><ul><li>Path drift (new disk/NVMe): use <code>.env</code> for paths; avoid hardcoded systemd units.</li><li>Transient laptops: taint them; no critical pods scheduled there.</li><li>RPi thermal limits: use low resource requests/limits; keep control-plane off RPis.</li><li>Security: if you need rootless for dev, run rootless Docker/Podman for non-Swarm workloads; keep Swarm/k3s rootful on the PC.</li></ul><h2 id="next-actions-to-kick-off-after-reboot" tabindex="-1">Next actions to kick off after reboot <a class="header-anchor" href="#next-actions-to-kick-off-after-reboot" aria-label="Permalink to &quot;Next actions to kick off after reboot&quot;">‚Äã</a></h2><ul><li>Enable Docker; run compose using bind-mounted configs.</li><li>Export current Komga Podman volume ‚Üí host config dir; update compose/systemd to bind mounts.</li><li>Add <code>.env.example</code> with COMICS_ROOT/KOMGA_CONFIG/KOMGA_TMP defaults.</li><li>Draft k3s install/runbook (PC control-plane, RPi workers).</li></ul><h2 id="komga-config-migration-plan-only-do-post-reboot" tabindex="-1">Komga config migration (plan only; do post-reboot) <a class="header-anchor" href="#komga-config-migration-plan-only-do-post-reboot" aria-label="Permalink to &quot;Komga config migration (plan only; do post-reboot)&quot;">‚Äã</a></h2><ul><li>Stop service: <code>systemctl --user stop container-komga.service</code> (or <code>podman stop komga</code>).</li><li>Discover volume name: <code>podman volume ls</code> and note the Komga config volume; inspect if needed: <code>podman volume inspect &lt;VOL&gt;</code>.</li><li>Backup old volume (create backup dir first): <code>mkdir -p /srv/komga/backup</code> (or a user-writable path) then <code>podman run --rm -v &lt;VOL&gt;:/from -v /srv/komga/backup:/backup alpine sh -c &quot;cd /from &amp;&amp; tar cf /backup/komga-config.tar .&quot;</code></li><li>Ensure bind paths writable in rootless mode: either use a user-owned path (e.g., <code>$HOME/.local/share/komga/config</code> and <code>/tmp/komga</code>) or <code>sudo mkdir -p /srv/komga/{config,tmp,backup} &amp;&amp; sudo chown -R $(id -u):$(id -g) /srv/komga</code>.</li><li>Migrate to bind mounts: <code>podman run --rm -v &lt;VOL&gt;:/from -v /srv/komga/config:/to alpine sh -c &quot;cd /from &amp;&amp; tar cf - . | (cd /to &amp;&amp; tar xf -)&quot;</code> (repeat for <code>/tmp</code> if needed). On SELinux hosts keep <code>:Z</code> in compose; on non-SELinux hosts it is ignored.</li><li>Update <code>docker-compose.komga.yml</code> + <code>.env</code> to use bind mounts (<code>COMICS_ROOT</code>, <code>KOMGA_CONFIG=/srv/komga/config</code>, <code>KOMGA_TMP=/srv/komga/tmp</code> or <code>$HOME/.local/share/...</code>); recreate with compose (Podman or Docker).</li><li>Verify: login with existing user; libraries present; Komf reaches Komga; scan succeeds; thumbnails intact; check logs for errors.</li><li>Rollback (if needed): stop service, recreate container pointing back to the saved Podman volume or untar the backup into a fresh bind; keep the original volume until stable for several days.</li></ul><h2 id="mount-gating-and-boot-determinism" tabindex="-1">Mount gating and boot determinism <a class="header-anchor" href="#mount-gating-and-boot-determinism" aria-label="Permalink to &quot;Mount gating and boot determinism&quot;">‚Äã</a></h2><ul><li>Use a compose-based systemd (or Quadlet) user unit with <strong>literal absolute paths</strong> in <code>RequiresMountsFor=/path/to/mount</code> (no shell expansion in units) plus an <code>ExecStartPre</code> loop that waits for the mount (e.g., 30x5s). If the mount is missing, the unit should fail fast and systemd will retry; once the mount appears, <code>systemctl --user restart container-komga</code> succeeds without data loss. If templating is needed, generate the unit from <code>.env</code>.</li><li>For Swarm/K8s, ensure shared storage or placement constraints prevent scheduling on nodes without the bind path.</li></ul><h2 id="selinux-portability" tabindex="-1">SELinux portability <a class="header-anchor" href="#selinux-portability" aria-label="Permalink to &quot;SELinux portability&quot;">‚Äã</a></h2><ul><li>Default to <code>:Z</code> on bind mounts; on non-SELinux hosts it is ignored by Docker/Podman. If a host enforces SELinux and the path is shared, use <code>:z</code> only when multiple containers share the same content; otherwise keep <code>:Z</code>. Avoid applying :Z/üòí to broad/shared host paths to prevent unwanted relabeling. Document overrides in <code>.env.example</code> or a compose override for SELinux vs non-SELinux hosts.</li></ul><h2 id="runtime-note-for-k3s" tabindex="-1">Runtime note for k3s <a class="header-anchor" href="#runtime-note-for-k3s" aria-label="Permalink to &quot;Runtime note for k3s&quot;">‚Äã</a></h2><ul><li>In k3s the container runtime is containerd; Docker/Podman are for build/push and single-host runs. Build multi-arch images with <code>docker buildx</code> and push to GHCR; k3s pulls the right arch automatically.</li></ul><h2 id="compose-portability-podman-vs-docker" tabindex="-1">Compose portability (Podman vs Docker) <a class="header-anchor" href="#compose-portability-podman-vs-docker" aria-label="Permalink to &quot;Compose portability (Podman vs Docker)&quot;">‚Äã</a></h2><ul><li>Tested path: <code>podman compose</code> (v4+) and <code>docker compose v2</code>.</li><li>Avoid: legacy <code>podman-compose</code> python tool; compose features outside v3.9 core (e.g., experimental secrets drivers, swarm-only networking assumptions) when running on Podman.</li></ul><h2 id="definition-of-done-post-reboot" tabindex="-1">Definition of Done (post-reboot) <a class="header-anchor" href="#definition-of-done-post-reboot" aria-label="Permalink to &quot;Definition of Done (post-reboot)&quot;">‚Äã</a></h2><ul><li>Fresh clone + <code>.env</code> ‚Üí <code>docker compose -f docker-compose.komga.yml up -d</code> (or <code>podman compose ...</code>) succeeds.</li><li>Komga/Komf survive reboot with mounts present; if mounts absent, services do not corrupt state and recover automatically once mounts return.</li><li>Migration validated: existing user login works, libraries present, scan succeeds, Komf enrichment works, thumbnails intact.</li><li>Backup/restore tested once (using the tar backup) on a throwaway path.</li></ul>',29)]))}const h=o(s,[["render",i]]);export{p as __pageData,h as default};
